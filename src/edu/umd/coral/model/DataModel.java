/*******************************************************************************
 * Copyright (c) 2012 Darya Filippova.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Public License v3.0
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/gpl.html
 * 
 * Contributors:
 *     Darya Filippova - initial API and implementation
 ******************************************************************************/
package edu.umd.coral.model;

import java.awt.Color;
import java.beans.PropertyChangeSupport;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

import javax.swing.JFrame;

import net.infonode.docking.View;
import edu.umd.coral.clustering.LapFasterReordering;
import edu.umd.coral.clustering.MatrixReordering;
import edu.umd.coral.managers.CliqueManager;
import edu.umd.coral.managers.FastDenseSubgraphFinder;
import edu.umd.coral.model.data.Clique;
import edu.umd.coral.model.data.Clustering;
import edu.umd.coral.model.data.ComparisonScores;
import edu.umd.coral.model.data.Cooccurrence;
import edu.umd.coral.model.data.Edge;
import edu.umd.coral.model.data.Matrix;
import edu.umd.coral.model.data.Score;
import edu.umd.coral.model.data.Vertex;
import edu.umd.coral.model.metrics.Metric;
import edu.umd.coral.model.metrics.MetricFactory;


	/**
	 * DataModel is the main model for the CORAL program. It contains the vertices, clusterings,
	 * edges, and zoom value. It also sets up the strings to test the PropertyChange's. There is 
	 * one DataModel created during the program's instantiation and it is changed based on what 
	 * data is loaded.
	 */

public class DataModel extends PropertyChangeSupport  {
	
	/**
	 * generated by eclipse
	 */
	private static final long serialVersionUID = 1L;

	// event names
	
	public static final String ORIGINAL_MATRIX_CHANGED = "originalMatrixChanged";
	
	public static final String MATRIX_CHANGED = "currentMatrixChanged";	
	
	public static final String CLUSTERINGS_CHANGED = "clusteringsChanged";
	
	public static final String VERTICES_CHANGED = "verticesChanged";
	
	public static final String VERTEX_PAIRS_CHANGED = "vertexPairsChanged";
	
	public static final String SELECTED_VERTICES_CHANGED = "selectedVerticesChanged";

	public static final String SELECTED_METRIC_CHANGED = "selectedMetricChanged";
	
	public static final String SELECTED_CLUSTERING_PAIR_CHANGED = "selectedClustPairChanged";
	
	public static final String METRIC_SCORES_CHANGED = "metricsScoresChanged";
	
	public static final String SELECTED_CLUSTERING_CHANGED = "selectedClusteringChanged";
	
	public static final String COOCCUR_CHANGED = "cooccurChanged";

	public static final String EDGES_CHANGED = "edgesChanged";
	
	public static final String BG_COLOR_CHANGED = "bgColorChanged";
	
	public static final String BOUND_CHANGED = "boundChanged";
	
	public static final String ZOOM_CHANGED = "zoomChanged";
	
//	public static final String WEIGHTED_CHANGED = "weightedChanged";

	public static final String WEIGHT_RANGE_CHANGED = "weightRangeChanged";

//	public static final String CLUSTERING_SCORES_CHANGED = "clusteringScoresChanged";
	
	public static final String BOUNDRY_WEIGHT_CHANGED = "boundryWeightChanged";
	
	public static final String INTERNAL_CHANGED = "internalChanged";
	
	public static final String NETWORK_LOADED = "networkLoaded";
	
	public static final String CLUSTERING_ORDERING_CHANGED = "clusteringOrderingChanged";
	
	public static final String HIGHLIGHT_CLIQUES_CHANGED = "highlightCliquesChanged";
	
	public static final String OVERLAY_CLIQUES_CHANGED = "overlayCliques";
	
	public static final String CLIQUES_MATRIX_CHANGED = "cliquesChanged";
	
	public static final String SELECTION_MODE_CHANGED = "selectionModeChanged";
	
	public static final String DEFAULT_PATH_CHANGED = "defaultPathChanged";
	
	// what is this??? prop file?
	public static final String PROPERTIES = ".properties";

	public static final String SHOW_P_LABELS_CHANGED = "showPLabelsChanged";
	
	public static final String SHOW_P_ITEMS_CHANGED = "showPItemsChanged";

	public static final String VERTEX_TABLE_COLUMNS_CHANGED = "vertexTableColumnsChanged";
	
	public static final String MODULE_TABLE_COLUMNS_CHANGED = "moduleTableColumnsChanged";

	public static final String CLUSTERING_PP_ORDERING_CHANGED = "ppClusteringOrderingChanged";
	
	public static final String SEARCH_ITEM_CHANGED = "searchItemChanged";

	public static final String INITIAL_ORDER_SET = "initialOrderSet";

	public static final String INCLUDE_GRAB_BAG_CHANGED = "includeGrabBagChanged";

	public static final String MODULE_SPACING_CHANGED = "moduleSpacingChanged";
	
	
	public JFrame getMainWindow() {
		return _appWindow;
	}
	private JFrame _appWindow;
	
	/**
	 * 
	 * @return
	 */
	public Matrix getOriginalMatrix() {
		return originalMatrix;
	}
	public void setOriginalMatrix(Matrix value) {
		Matrix oldValue = originalMatrix;
		originalMatrix = value;
		
		this.setHighlightCliques(false);
		this.setCliques(null);
		
		firePropertyChange(ORIGINAL_MATRIX_CHANGED, oldValue, originalMatrix);
	}
	private Matrix originalMatrix = null;

	
	/**
	 * Current matrix as a sum of all clusterings selected in the options. The 
	 * values below and above the lower and upper bound are stored as 0's.
	 *  
	 * @see Matrix
	 * 
	 * @return current Matrix object or null if no clusterings were loaded
	 */
	public Matrix getCurrentMatrix() {
		return _currentMatrix;
	}
	public void setCurrentMatrix(Matrix value) {
		Matrix oldValue = _currentMatrix;
		_currentMatrix = value;
		
		// dispatch an event
		firePropertyChange(MATRIX_CHANGED, oldValue, _currentMatrix);
	}
	private Matrix _currentMatrix = null;
	
	
	/**
	 * @return
	 */
	public Map<String, Clustering> getClusterings() {
		return _clusterings;
	}
	public void setClusterings(Map<String, Clustering> value) {
		Map<String, Clustering> oldValue = _clusterings;
		_clusterings = value;
		
		firePropertyChange(CLUSTERINGS_CHANGED, oldValue, _clusterings);
	}
	private Map<String, Clustering> _clusterings = null;
	
	
	/**
	 * SelectedClustering = currently shown in the "compare clusterings" tab
	 * @return
	 */
	public Clustering getSelectedClustering() {
		return _selectedClustering;
	}
	public void setSelectedClustering(Clustering value) {
		Clustering oldValue = _selectedClustering; 
		_selectedClustering = value;
		
		firePropertyChange(SELECTED_CLUSTERING_CHANGED, oldValue, _selectedClustering);
	}
	private Clustering _selectedClustering = null;
	
	
	/**
	 * @return
	 */
	public Map<String, Vertex> getVertices() {
		return _vertices;
	}
	public void setVertices(Map<String, Vertex> value) {
		Map<String, Vertex> oldValue = _vertices;
		_vertices = value;
		
		firePropertyChange(VERTICES_CHANGED, oldValue, _vertices);
	}
	private Map<String, Vertex> _vertices = null;

	
	/**
	 * Vertex Pairs - tuples w/ vertex-vertex and their co-occurrence
	 * 
	 * @return
	 */
	public Map<Vertex, TreeMap<Vertex, Cooccurrence>> getVertexPairs() {
		return _vertexPairs;
	}
	public void setVertexPairs( Map<Vertex, TreeMap<Vertex, Cooccurrence>> value) {
		 Map<Vertex, TreeMap<Vertex, Cooccurrence>> oldValue = _vertexPairs;
		_vertexPairs = value;
		
		firePropertyChange(VERTEX_PAIRS_CHANGED, oldValue, _vertexPairs);
	}
	private  Map<Vertex, TreeMap<Vertex, Cooccurrence>> _vertexPairs = null;
	
	
	/**
	 * 
	 * @return
	 */
	public ArrayList<String> getVertexTableColumns() {
		return _vertexTableColumns;
	}
	public void setVertexTableColumns( ArrayList<String> value) {
		 ArrayList<String> oldValue = _vertexTableColumns;
		 _vertexTableColumns = value;
		
		firePropertyChange(VERTEX_TABLE_COLUMNS_CHANGED, oldValue, _vertexPairs);
	}
	private  ArrayList<String> _vertexTableColumns = null;
	
	
	
	/**
	 * 
	 * @return
	 */
	public ArrayList<String> getModuleTableColumns() {
		return _moduleTableColumns;
	}
	public void setModuleTableColumns( ArrayList<String> value) {
		 ArrayList<String> oldValue = _moduleTableColumns;
		 _moduleTableColumns = value;
		
		firePropertyChange(MODULE_TABLE_COLUMNS_CHANGED, oldValue, _vertexPairs);
	}
	private  ArrayList<String> _moduleTableColumns = null;
	
	
	/**
	 * 
	 * @return
	 */
	public Metric getSelectedMetric() {
		return _selectedMetric;
	}
	public void setSelectedMetric(Metric value) {
		Metric oldValue = _selectedMetric;
		_selectedMetric = value;
		
		firePropertyChange(SELECTED_METRIC_CHANGED, oldValue, _selectedMetric);
	}
	private Metric _selectedMetric = MetricFactory.getMetricInstance(MetricFactory.JACCARD);
	
	
	/**
	 * Getter and setter for a selected vertex pair - set when user clicks on 
	 * the matrix
	 * @return
	 */
	public ArrayList<Vertex> getSelectedVertices() {
		return _selectedVertices;
	}
	public void setSelectedVertices(ArrayList<Vertex> pair) {
		//System.out.println(pair.toString());
		
		ArrayList<Vertex> oldValue = _selectedVertices;
		_selectedVertices = pair;
		
		// dispatch an event that the pair has changed
		firePropertyChange(SELECTED_VERTICES_CHANGED, oldValue, _selectedVertices);
	}
	private ArrayList<Vertex> _selectedVertices = null;
	
//	public void setSelectedVertices(Collection<Vertex> selected) {
//		// TODO Auto-generated method stub
//		
//	}


	/**
	 * Metric to clustering-2-clustering scores calculcated using that metric
	 * 
	 */
	public Score<Clustering> getSelectedClusteringPair() {
		return _selectedClusteringPair;
	}
	public void setSelectedClusteringPair(Score<Clustering> value) {
		Score<Clustering> oldValue = _selectedClusteringPair;
		_selectedClusteringPair = value;
		
		firePropertyChange(SELECTED_CLUSTERING_PAIR_CHANGED, oldValue, _selectedClusteringPair);
	}
	private Score<Clustering> _selectedClusteringPair;
	
	
	/**
	 * Metric to clustering-2-clustering scores calculated using that metric
	 * 
	 * @return
	 */	
	public ComparisonScores<Clustering> getScores(String value) {
		if (_metric2Score != null)
			return _metric2Score.get(value);
		return null;
	}
//	public void setMetric2Score(Map<String, ComparisonScores<Clustering>> value) {
//		Map<String, ComparisonScores<Clustering>> oldValue = _metric2Score;
//		
//		_metric2Score = value;
//		
//		// property won't fire unless the value actually changed, right?
//		// so adding items to collection won't trigger this update
//		firePropertyChange(METRIC_SCORES_CHANGED, oldValue, _metric2Score);
//	}
	public void addScores(Metric m, ComparisonScores<Clustering> value) {
		ComparisonScores<Clustering> oldValue;
		if (_metric2Score == null) {
			oldValue = null;
			_metric2Score = new HashMap<String, ComparisonScores<Clustering>>();
		}
		else {
			oldValue = _metric2Score.get(m.getName());
			_metric2Score.put(m.getName(), value);
		}
		
		firePropertyChange(METRIC_SCORES_CHANGED, oldValue, value);
	}
	private Map<String, ComparisonScores<Clustering>> _metric2Score = 
			new HashMap<String, ComparisonScores<Clustering>>();
	
	
	/**
	 * 
	 * @return
	public ComparisonScores<Clustering> getClusteringScores() {
		return _clusteringScores;
	}
	public void setClusteringScores(ComparisonScores<Clustering> scores) {
		ComparisonScores<Clustering> oldValue = _clusteringScores;
		_clusteringScores = scores;
		
		firePropertyChange(DataModel.CLUSTERING_SCORES_CHANGED, oldValue, _clusteringScores);
	}
	private ComparisonScores<Clustering> _clusteringScores;
	*/
	
	
	/**
	 * Edges - contains a collection of edges in the original network. 
	 * 
	 * @see Edge
	 * 
	 * @return Collection of Edge objects
	 */
	public Collection<Edge<Vertex>> getEdges() {
		return _edges;
	}
	public void setEdges(Collection<Edge<Vertex>> value) {
		Collection<Edge<Vertex>> oldValue = _edges;
		_edges = value;
		
		firePropertyChange(EDGES_CHANGED, oldValue, value);
	}
	private Collection<Edge<Vertex>> _edges = new ArrayList<Edge<Vertex>>();
	
	
	public boolean hasEdges() {
		return _hasEdges;
	}
	public void setHasEdges(boolean value) {
		boolean oldValue = _hasEdges;
		this._hasEdges = value;
		
		firePropertyChange(EDGES_CHANGED, oldValue, value);
	}
	private boolean _hasEdges = false;
	
	
	
	
	/**
	 * Defines the background color for co-occurrence matrix
	 * 
	 * @return
	 */
	public Color getBackgroundColor() {
		return _backgroundColor;
	}
	public void setBackgroundColor(Color value) {
		Color oldValue= _backgroundColor;
		_backgroundColor = value;
		
		firePropertyChange(BG_COLOR_CHANGED, oldValue, value);
	}
	private Color _backgroundColor = Color.BLACK;
	
	
	/**
	 * Lower bound: co-occurrence below this value will not be shown on the
	 * co-occurrence matrix
	 * 
	 * @return current value of the lower co-occurrence cut off value
	 */
	public int getLowerBound() {
		return _lowerBound;
	}
	public void setLowerBound(int value) {
		int oldValue = _lowerBound;
		_lowerBound = value;
		
		firePropertyChange(BOUND_CHANGED, oldValue, value);
	}
	private int _lowerBound;
	

	/**
	 * Upper bound: co-occurrences above this value will not be shown on the 
	 * co-occurrence matrix
	 * 
	 * @return current value for the upper co-occurrence cut off value 
	 */
	public int getUpperBound() {
		return _upperBound;
	}
	public void setUpperBound(int value) {
		int oldValue = _upperBound;
		_upperBound = value;
		
		firePropertyChange(BOUND_CHANGED, oldValue, value);
	}
	private int _upperBound;
	
	
	/**
	 * Zoom value for the big matrix, 1.00 == 100%
	 * 
	 * @param selection
	 */
	public float getZoomValue() {
		return _zoomValue;
	}
	public void setZoomValue(float value) {
		if (value < 0.2f)
			value = 0.2f;
		if (value > 10.0f)
			value = 10.0f;
		
		float oldValue = _zoomValue;
		_zoomValue = value;
		
		firePropertyChange(ZOOM_CHANGED, oldValue, value);
	}
	private float _zoomValue = 1.0f;
	
	
	/**
	 * TODO
	 * @return
	 */
	public boolean isWeighted() {
		return _isWeighted;
	}
	public void setWeighted(boolean isWeighted) {
		this._isWeighted = isWeighted;
		
		// TODO
//		firePropertyChange(WEIGHTED_CHANGED, !isWeighted, isWeighted);
	}
	private boolean _isWeighted = false;

	
	/**
	 * TODO
	 * @return
	 */
	public int getMaxWeight() {
		return _maxWeight;
	}
	public void setMaxWeight(float value) {
		int oldValue = _maxWeight;
		_maxWeight = (int)Math.ceil(value);
		
		firePropertyChange(WEIGHT_RANGE_CHANGED, oldValue, value);
	}
	private int _maxWeight;
	
	
	/**
	 * TODO
	 * @return
	 */
	public int getMinWeight() {
		return _minWeight;
	}
	public void setMinWeight(float value) {
		float oldValue = _minWeight;
		_minWeight = (int)Math.floor(value);
		
		firePropertyChange(WEIGHT_RANGE_CHANGED, oldValue, value);
	}
	private int _minWeight;
	
	
	/**
	 * TODO
	 * @return
	 */
	public int getHighWeight() {
		return _highWeight;
	}
	public void setHighWeight(int value) {
		int oldValue = _highWeight;
		_highWeight = value;
		
		firePropertyChange(BOUNDRY_WEIGHT_CHANGED, oldValue, value);
	}
	private int _highWeight;
	
	
	/**
	 * TODO
	 * @return
	 */
	public int getLowWeight() {
		return _lowWeight;
	}
	public void setLowWeight(int value) {
		float oldValue = _lowWeight;
		_lowWeight = value;
		
		firePropertyChange(BOUNDRY_WEIGHT_CHANGED, oldValue, value);
	}
	private int _lowWeight;
	
	
	/**
	 * TODO
	 * @return
	 */
	public boolean isInternal() {
		return _isInternal;
	}
	public void setInternal(boolean isInternal) {
		this._isInternal = isInternal;
		
		firePropertyChange(INTERNAL_CHANGED, !isInternal, isInternal);
	}
	private boolean _isInternal = false;
	
	
	/**
	 * Matrix reordering parameters. Number of optimal reordering interactions 
	 * to run on the matrix.
	 * 
	 * @return
	 */
	public int getMatrixGreedyIterations() {
		return greedyIter;
	}
	public void setMatrixGreedyIterations(int value) {
		greedyIter = value;
	}
	private int greedyIter = 1;
	
	
	/**
	 * Number of optimal reordering interactions to run on the matrix 
	 * @return
	 */
	public int getMatrixOptIterations() {
		return optIter;
	}
	public void setMatrixOptIterations(int value) {
		optIter = value;
	} 
	private int optIter;
	
	
	/**
	 * RowReordering - with a mapping of vertex indices to vertex names
	 * 
	 * @return
	 */
	public MatrixReordering getReordering() {
		return _reordering;
	}
	private MatrixReordering _reordering = new LapFasterReordering(greedyIter, optIter);
	
	/**
	 * Clustering ordering in v2v table, all clusterings list.
	 * 
	 * @param sortedClusterings
	 * @return
	 */
	public ArrayList<Clustering> getClusteringOrdering() {
		return _clustOrdering;
	}
	public void setClusteringOrdering(ArrayList<Clustering> value) {
		ArrayList<Clustering> oldValue = _clustOrdering;
		_clustOrdering = value;
		
		firePropertyChange(CLUSTERING_ORDERING_CHANGED, oldValue, value);
	}
	private ArrayList<Clustering> _clustOrdering;
	
	
	
	public ArrayList<Clustering> getPPClusteringOrdering() {
		return _clustPPOrdering;
	}
	public void setPPClusteringOrdering(ArrayList<Clustering> value) {
		ArrayList<Clustering> oldValue = _clustPPOrdering;
		
		_clustPPOrdering = value;
		
		firePropertyChange(CLUSTERING_PP_ORDERING_CHANGED, oldValue, value);
	}
	private ArrayList<Clustering> _clustPPOrdering;
	
	
	/**
	 * 
	 * @return
	 */
	public boolean getHighlightCliques() {
		return _highlightCliques;
	}
	public void setHighlightCliques(boolean value) {
		boolean oldValue = _highlightCliques;
		_highlightCliques = value;
		
		firePropertyChange(HIGHLIGHT_CLIQUES_CHANGED, oldValue, value);
	}
	private boolean _highlightCliques = false;
	
	
	/**
	 * 
	 */
	public boolean getOverlayCliques() {
		return _overlayCliques;
	}
	public void setOverlayCliques(boolean value) {
		boolean oldValue = _overlayCliques;
		_overlayCliques = value;
		
		firePropertyChange(OVERLAY_CLIQUES_CHANGED, oldValue, value);
	}
	private boolean _overlayCliques = false;
	
	
	/**
	 * Collection of collections of vertices where each collection of
	 * vertices is a dense subgraph in matrix identified by some method
	 * (Maximal cliques, loose cliques,optimal collection of dense subgraphs)  
	 * @return
	 */
	public Collection<Clique> getCliques() {
		return _cliqueMatrix;
	}
	public void setCliques(Collection<Clique> value) {
		Collection<Clique> oldValue = _cliqueMatrix;
		_cliqueMatrix = value;
		
		// dispatch an event
		firePropertyChange(CLIQUES_MATRIX_CHANGED, oldValue, _cliqueMatrix);
	}
	private Collection<Clique> _cliqueMatrix;
	
	public CliqueManager getCliqueManager() {
		return _cliqueManager;
	}
//	private CliqueManager _cliqueManager = new DenseSubgraphFinder();
	private CliqueManager _cliqueManager = new FastDenseSubgraphFinder();
	
	
	public String getSelectionMode() {
		return _selectionMode;
	}
	public void setSelectionMode(String value) {
		String oldValue = _selectionMode;
		_selectionMode = value;
		
		// dispatch an event
		firePropertyChange(SELECTION_MODE_CHANGED, oldValue, _selectionMode);
	}
	private String _selectionMode = MatrixSelectionMode.SELECT_ZOOM_REGION;
	
	
	/**
	 * 
	 */
	public String getLastPath() {
		return _lastUsedPath;
	}
	public void setLastPath(String value) {
		String oldValue = _lastUsedPath;
		_lastUsedPath = value;
		
		// dispatch an event
		firePropertyChange(DEFAULT_PATH_CHANGED, oldValue, _lastUsedPath);
	}
	private String _lastUsedPath;
	
	
	/**
	 * 
	 * @return
	 */
	public boolean getShowPLabels() {
		return _showPLabels;
	}
	public void setShowPLabels(boolean value) {
		boolean oldVal = this._showPLabels;
		
		this._showPLabels = value;
		this.firePropertyChange(SHOW_P_LABELS_CHANGED, oldVal, value);
	}
	private boolean _showPLabels = true;
	
	
	/**
	 * 
	 * @return
	 */
	public boolean getShowPItems() {
		return _showPItems;
	}
	public void setShowPItems(boolean value) {
		boolean oldVal = this._showPItems;
		
		this._showPItems = value;
		this.firePropertyChange(SHOW_P_ITEMS_CHANGED, oldVal, value);
	}
	private boolean _showPItems = true;
	
	
	/**
	 * Constructor
	 * 
	 * @param coralMainWindow
	 */
	public DataModel(JFrame c) {
		// new model
		super(c);
		_appWindow = c;
	}
	
	
	/**
	 * Create the co-occurrence matrix with the given model. Notifies all views
	 * listening to the properties of about their changes.
	 * 
	 * @return the co-occurrence matrix (which is also stored)
	 */
	public void reset(){
		_hasEdges = false;
		_reordering = null;
		setOriginalMatrix(null);
		setCurrentMatrix(null);
		setClusterings(null);
		this._metric2Score.clear();
		
		setSelectedClustering(null);
		this.setSelectedMetric(MetricFactory.getMetricInstance(MetricFactory.JACCARD));
		this.setSelectedClusteringPair(null);
		setVertices(null);
		setSelectedVertices(null);
		setBackgroundColor(Color.BLACK);
		setInitialVertexOrder(null);
		setZoomValue(1.0f);
		setWeighted(false);
		setInternal(false);
		this.setEdges(null);
		this.setHighlightCliques(false);
		this.setOverlayCliques(false);
	}
	
	/**
	 * Property. If true, put all singleton vertices into one module; if false,
	 * put each such vertex into a separate module.
	 * 
	 * @param property
	 */
	public void setAggregateSingletons(boolean p) {
		this._aggregateSingletons = p;
	}
	public boolean getAggregateSingletons() {
		return _aggregateSingletons;
	}
	private boolean _aggregateSingletons = true;


	/**
	 * Base clustering when comparing base clustering and how it is confirmed by
	 * other clusterings
	 * 
	 * @param c
	 */
	public void setBaseClustering(Clustering c) {
		_baseClustering = c;
	}
	public Clustering getBaseClustering() {
		return _baseClustering;
	}
	private Clustering _baseClustering = null;


	/**
	 * initial vertex order is determined by the order of modules and vertices
	 * in those modules form the first clustering file that is read through 
	 * ModuleFilesParser
	 * 
	 * @return
	 */
	public ArrayList<Vertex> getInitialVertexOrder() {
		return _initialOrder;
	}
	public void setInitialVertexOrder(ArrayList<Vertex> value) {
		ArrayList<Vertex> oldValue = _initialOrder;
		_initialOrder = value;
		
		// dispatch an event
		firePropertyChange(INITIAL_ORDER_SET, oldValue, _initialOrder);
	}
	private ArrayList<Vertex> _initialOrder;

	public boolean isDebug() {
		return debug;
	}
	private final boolean debug = false;

	public void setSearchString(String text) {
		// TODO: blah
	}
	
	public View [] getViews() {
		return views;
	}
	public void setViews(View[] value) {	
		views = value;
	}
	private View [] views;
	
	// search item
	public Vertex getSearchItem() {
		return searchItem;
	}
	public void setSearchItem(Vertex value) {
		Vertex oldVal = searchItem;
		searchItem = value;
		this.firePropertyChange(SEARCH_ITEM_CHANGED, oldVal, value);
	}
	private Vertex searchItem;


	/**
	 * A boolean flag specifying whether to include the grab bag cluster or not 
	 * in similarity calculation 
	 * @return
	 */
	public boolean getIncludeGrabBag() {
		return _includeGrabBag;
	}
//	private void setIncludeGrabBag(boolean value) {
//		boolean oldValue = _grabBag;
//		_grabBag = value;
//		this.firePropertyChange(INCLUDE_GRAB_BAG_CHANGED, oldValue, value);
//	}
	private boolean _includeGrabBag = false;
	
	
	/**
	 * Spacing between modules in PPP, in pixels
	 * @return
	 */
	public int getModuleSpacing() {
		return _moduleSpacing;
	}
	public void setModuleSpacing(int value) {
		int oldValue = _moduleSpacing;
		_moduleSpacing = value;
		this.firePropertyChange(MODULE_SPACING_CHANGED, oldValue, value);
	}
	private int _moduleSpacing = 5;
}
